function st(t){return Array.from(new Set(t))}const at="0.4.204",E={projectName:"Vike",projectVersion:at},I=`_${E.projectName.toLowerCase()}`;function R(t,e){const n=ct();return n[t]=n[t]||e}function ct(){return globalThis[I]=globalThis[I]||{}}const c=new Proxy({},{get:(t,e)=>n=>e==="code"?`\`${n}\``:e==="string"?`'${n}'`:n}),g=R("assertSingleInstance.ts",{instances:[],alreadyLogged:new Set}),ut="Client runtime of both Server Routing and Client Routing loaded https://vike.dev/client-runtimes-conflict",D="Client runtime loaded twice https://vike.dev/client-runtime-duplicated";function J(){{const t=st(g.instances);ft(t.length<=1,`vike@${c.bold(t[0])} and vike@${c.bold(t[1])} loaded but only one version should be loaded`)}g.checkSingleInstance&&g.instances.length>1&&T(!1,D,{onlyOnce:!0,showStackTrace:!0})}function Ft(t){T(g.isClientRouting!==!1,ut,{onlyOnce:!0,showStackTrace:!0}),T(g.isClientRouting===void 0,D,{onlyOnce:!0,showStackTrace:!0}),g.isClientRouting=!0,g.checkSingleInstance=!0,J()}function lt(){g.instances.push(E.projectVersion),J()}function ft(t,e){if(t)return;const n=`[vike][Wrong Usage] ${e}`;throw new Error(n)}function T(t,e,{onlyOnce:n,showStackTrace:r}){if(t)return;const o=`[vike][Warning] ${e}`;if(n){const{alreadyLogged:i}=g,s=n===!0?o:n;if(i.has(s))return;i.add(s)}console.warn(r?new Error(o):o)}function ht(){return!(typeof process>"u"||!process.cwd||!process.versions||typeof process.versions.node>"u"||!process.release||process.release.name!=="node")}function S(t,e){const n=new Error(t);return ht()&&(n.stack=dt(n.stack,e)),n}function dt(t,e){if(!t)return t;const n=gt(t);let r=0;return n.filter(i=>i.includes(" (internal/")||i.includes(" (node:internal")?!1:r<e&&pt(i)?(r++,!1):!0).join(`
`)}function pt(t){return t.startsWith("    at ")}function gt(t){return t.split(/\r?\n/)}function j(t){return typeof t=="object"&&t!==null}const u=R("utils/assert.ts",{alreadyLogged:new Set,logger(t,e){e==="info"?console.log(t):console.warn(t)},showStackTraceList:new WeakSet});lt();const bt="[vike]",mt=`[vike@${E.projectVersion}]`,v=2;function a(t,e){if(t)return;const n=(()=>{if(!e)return null;const s=typeof e=="string"?e:JSON.stringify(e);return c.dim(`Debug info (for Vike maintainers; you can ignore this): ${s}`)})();let o=[`You stumbled upon a Vike bug. Go to ${c.blue("https://github.com/vikejs/vike/issues/new")} and copy-paste this error. A maintainer will fix the bug (usually under 24 hours).`,n].filter(Boolean).join(" ");o=w(o),o=P(o,"Bug"),o=k(o,!0);const i=S(o,v);throw u.onBeforeLog?.(),i}function O(t,e,{showStackTrace:n}={}){if(t)return;n=n||u.alwaysShowStackTrace,e=w(e),e=P(e,"Wrong Usage"),e=k(e);const r=S(e,v);throw n&&u.showStackTraceList.add(r),u.onBeforeLog?.(),r}function wt(t){return t=w(t),t=P(t,"Error"),t=k(t),S(t,v)}function G(t,e,{onlyOnce:n,showStackTrace:r}){if(!t){if(r=r||u.alwaysShowStackTrace,e=w(e),e=P(e,"Warning"),e=k(e),n){const{alreadyLogged:o}=u,i=n===!0?e:n;if(o.has(i))return;o.add(i)}if(u.onBeforeLog?.(),r){const o=S(e,v);u.showStackTraceList.add(o),u.logger(o,"warn")}else u.logger(e,"warn")}}function Dt(t,e,{onlyOnce:n}){if(e=w(e),e=k(e),n){const{alreadyLogged:r}=u,o=e;if(r.has(o))return;r.add(o)}u.onBeforeLog?.(),u.logger(e,"info")}function P(t,e){let n=`[${e}]`;const r=e==="Warning"?"yellow":"red";return n=c.bold(c[r](n)),`${n}${t}`}function w(t){return t.startsWith("[")?t:` ${t}`}function k(t,e=!1){return`${e?mt:bt}${t}`}function _(t){const e=t/1e3;if(e<120){const n=B(e);return`${n} second${N(n)}`}{const n=e/60,r=B(n);return`${r} minute${N(r)}`}}function B(t){let e=t.toFixed(1);return e.endsWith(".0")&&(e=e.slice(0,-2)),e}function N(t){return t==="1"?"":"s"}const C=R("utils/executeHook.ts",{userHookErrors:new WeakMap,pageContext:null});function Jt(t,e,n){const{hookName:r,hookFilePath:o,hookTimeout:{error:i,warning:s}}=e;let h,f;const W=new Promise((l,y)=>{h=p=>{b(),l(p)},f=p=>{b(),y(p)}}),b=()=>{m&&clearTimeout(m),d&&clearTimeout(d)},m=V(s)&&setTimeout(()=>{G(!1,`The ${r}() hook defined by ${o} is slow: it's taking more than ${_(s)} (https://vike.dev/hooksTimeout)`,{onlyOnce:!1})},s),d=V(i)&&setTimeout(()=>{const l=wt(`The ${r}() hook defined by ${o} timed out: it didn't finish after ${_(i)} (https://vike.dev/hooksTimeout)`);f(l)},i);return(async()=>{try{kt(n);const l=await t();h(l)}catch(l){j(l)&&C.userHookErrors.set(l,{hookName:r,hookFilePath:o}),f(l)}})(),W}function V(t){return!!t&&t!==1/0}function kt(t){C.pageContext=t,Promise.resolve().then(()=>{C.pageContext=null})}function Y(){return typeof window<"u"&&typeof window.scrollY=="number"}const q=R("utils/assertRouterType.ts",{});function Wt(){$t(yt()),q.isClientRouting=!0}function yt(){return q.isClientRouting!==!1}function $t(t){O(Y(),`${c.cyan("import { something } from 'vike/client/router'")} is forbidden on the server-side`,{showStackTrace:!0}),G(t,"You shouldn't `import { something } from 'vike/client/router'` when using Server Routing. The 'vike/client/router' utilities work only with Client Routing. In particular, don't `import { navigate }` nor `import { prefetch }` as they unnecessarily bloat your client-side bundle sizes.",{showStackTrace:!0,onlyOnce:!0})}function jt(t){return t instanceof Function||typeof t=="function"}function A(t){return Array.isArray(t)}function Rt(t){return A(t)&&t.every(e=>typeof e=="string")}function St(t){return j(t)&&Object.values(t).every(e=>typeof e=="string")}function vt(t,e,n){if(!j(t))return!1;if(!(e in t))return n==="undefined";if(n===void 0)return!0;const r=t[e];return n==="undefined"?r===void 0:n==="array"?A(r):n==="object"?j(r):n==="string[]"?Rt(r):n==="string{}"?St(r):n==="function"?jt(r):A(n)?typeof r=="string"&&n.includes(r):n==="null"?r===null:n==="true"?r===!0:n==="false"?r===!1:typeof r===n}function K(t,e){e&&(a(!("_isPageContextObject"in e)),Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)))}function z(t,e,n){return typeof t=="string"?H(t.split(""),e,n).join(""):H(t,e,n)}function H(t,e,n){const r=[];let o=e>=0?e:t.length+e;a(o>=0&&o<=t.length);let i=n>=0?n:t.length+n;for(a(i>=0&&i<=t.length);!(o===i||(o===t.length&&(o=0),o===i));){const s=t[o];a(s!==void 0),r.push(s),o++}return r}function Gt(t,e){a(xt(t),t),a(e.startsWith("/"));const[n,...r]=t.split("#");a(n!==void 0);const o=["",...r].join("#")||null;a(o===null||o.startsWith("#"));const i=o===null?"":Q(o.slice(1)),[s,...h]=n.split("?");a(s!==void 0);const f=["",...h].join("?")||null;a(f===null||f.startsWith("?"));const W={},b={};Array.from(new URLSearchParams(f||"")).forEach(([$,L])=>{W[$]=L,b[$]=[...b.hasOwnProperty($)?b[$]:[],L]});let{protocol:m,origin:d,pathnameAbsoluteWithBase:l}=Pt(s,e);const y=s.slice((d||"").length);Ut(t,d,y,f,o);let{pathname:p,hasBaseServer:et}=At(l,e);const nt=Z(d,p,f,o),rt=d?d.slice(m.length):null,{hostname:ot,port:it}=Tt(rt,t);return p=Ot(p),a(p.startsWith("/")),{href:nt,protocol:m,hostname:ot,port:it,origin:d,pathname:p,pathnameOriginal:y,hasBaseServer:et,search:W,searchAll:b,searchOriginal:f,hash:i,hashOriginal:o}}function Q(t){try{return decodeURIComponent(t)}catch{}try{return decodeURI(t)}catch{}return t}function Ot(t){return t=t.replace(/\s+$/,""),t=t.split("/").map(e=>Q(e).split("/").join("%2F")).join("/"),t}function Pt(t,e){a(!t.includes("?")&&!t.includes("#"));{const{protocol:n,origin:r,pathname:o}=F(t);if(r)return{protocol:n,origin:r,pathnameAbsoluteWithBase:o};a(o===t)}if(t.startsWith("/"))return{protocol:null,origin:null,pathnameAbsoluteWithBase:t};{const n=typeof window<"u"?window?.document?.baseURI:void 0;let r;return n?r=F(n.split("?")[0].split("#")[0]).pathname:r=e,{protocol:null,origin:null,pathnameAbsoluteWithBase:Ct(t,r)}}}function F(t){if(x(t)){const{protocol:e,uriWithoutProtocol:n}=U(t);a(e);const[r,...o]=n.split("/"),i=e+r;return{pathname:"/"+o.join("/"),origin:i,protocol:e}}else return{pathname:t,origin:null,protocol:null}}function Tt(t,e){const n={hostname:null,port:null};if(!t)return n;const r=t.split(":");if(r.length>1){const o=parseInt(r.pop(),10);a(o||o===0,e),n.port=o}return n.hostname=r.join(":"),n}function U(t){const e=":",[n,...r]=t.split(e);if(r.length===0||!/^[a-z][a-z0-9\+\-]*$/i.test(n))return{protocol:null,uriWithoutProtocol:t};let o=n+e,i=r.join(e);const s="//";return i.startsWith(s)&&(o=o+s,i=i.slice(s.length)),{protocol:o,uriWithoutProtocol:i}}function X(t){return["ipfs://","ipns://"].includes(t)?!1:t.endsWith("://")}function Ct(t,e){const n=e.split("/"),r=t.split("/");let o=e.endsWith("/");t.startsWith(".")&&n.pop();for(const s in r){const h=r[s];h==""&&s==="0"||h!="."&&(h==".."?n.pop():(o=!1,n.push(h)))}let i=n.join("/");return o&&!i.endsWith("/")&&(i+="/"),i.startsWith("/")||(i="/"+i),i}function At(t,e){a(t.startsWith("/")),a(Et(e));let n=t;if(a(n.startsWith("/")),a(e.startsWith("/")),e==="/")return{pathname:t,hasBaseServer:!0};let r=e;return e.endsWith("/")&&n===z(e,0,-1)&&(r=z(e,0,-1),a(n===r)),n.startsWith(r)?(a(n.startsWith("/")||n.startsWith("http")),a(n.startsWith(r)),n=n.slice(r.length),n.startsWith("/")||(n="/"+n),a(n.startsWith("/")),{pathname:n,hasBaseServer:!0}):{pathname:t,hasBaseServer:!1}}function Et(t){return t.startsWith("/")}function Ut(t,e,n,r,o){const i=Z(e,n,r,o);a(t===i)}function Z(t,e,n,r){return`${t||""}${e}${n||""}${r||""}`}function xt(t){return x(t)||t.startsWith("/")||M(t)}function Lt(t){return t.startsWith("/")||It(t)||x(t)}function M(t){return[".","?","#"].some(e=>t.startsWith(e))||t===""}function Yt(t){return!t.startsWith("/")&&!M(t)}function x(t){const{protocol:e}=U(t);return!!e&&X(e)}function It(t){const{protocol:e}=U(t);return!!e&&!X(t)}function _t(t,e){Bt(t,e)}function Bt(t,e,{isRedirectTarget:n}={}){if(t.startsWith("/"))return;let r=`${e} is ${c.string(t)} but it should start with ${c.string("/")}`;if(n){if(Lt(t))return;if(r+=` or a protocol (${c.string("http://")}, ${c.string("mailto:")}, ...)`,n==="unresolved"){if(t==="*")return;r+=`, or be ${c.string("*")}`}}O(!1,r)}Y()&&Wt();function qt(t,e){const n=[JSON.stringify(t)],r="throw render()",o=`render(${n.join(", ")})`;return Nt(t,e,o,r)}function Nt(t,e,n,r,o){const i={abortReason:e,_abortCaller:r,_abortCall:n};{const s=t;return _t(s,Ht(r)),K(i,{_urlRewrite:s}),Vt(i)}}function Vt(t){const e=new Error("AbortRender");return K(e,{_pageContextAbort:t,[tt]:!0}),e}const tt="_isAbortError";function Kt(t){return typeof t=="object"&&t!==null&&tt in t}function Qt(t){return t._urlRewrite||t._urlRedirect||t.abortStatusCode?(a(vt(t,"_abortCall","string")),!0):!1}function Xt(t){zt(t);const e={_urlRewrite:null};return t.forEach(n=>{Object.assign(e,n)}),e}function zt(t){const e=[];t.forEach(n=>{const r=n._urlRewrite;{const o=e.indexOf(r);if(o!==-1){const i=[...e.slice(o),r].map(s=>`render('${s}')`).join(" => ");O(!1,`Infinite loop of render() calls: ${i}`)}}e.push(r)})}function Zt(t,e){const n=[t>0&&c.cyan("throw render('/some-url')"),e>0&&c.cyan("throw redirect('/some-url')")].filter(Boolean).join(" and ");O(t+e<=7,`Maximum chain length of 7 ${n} exceeded. Did you define an infinite loop of ${n}?`)}function Ht(t){return`URL passed to ${c.code(t)}`}export{Vt as A,Kt as B,Ft as C,a,O as b,A as c,G as d,j as e,Y as f,R as g,vt as h,jt as i,Wt as j,Gt as k,Jt as l,Qt as m,wt as n,K as o,c as p,Et as q,qt as r,z as s,xt as t,st as u,Yt as v,_t as w,Dt as x,Zt as y,Xt as z};
